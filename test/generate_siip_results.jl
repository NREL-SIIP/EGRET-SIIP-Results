#####################################################
# Surya
# NREL
# December 2021
# Generate SIIP results to comapre with EGRET Results
# TODO: Use EGRET SIIP System
        # Get rid of reserves
        # increase SCIP time
        # Upgrade to PSY 0.15 to get production cost
#####################################################
# Required Packages
#####################################################
using PowerSystems
const PSY = PowerSystems
using PowerSimulations
const PSI = PowerSimulations

using Dates
using DataFrames
using CSV

using SCIP
#####################################################
# Function to Save Results
##################################################### 
function save_to_csv(problem_name, sim_results)
    dir = joinpath(pwd(), "data", "CSV_Results")
    for (name, df) in sim_results
        CSV.write(joinpath(dir,"$(name)_$(problem_name).csv"), df)
    end
    return
end
#####################################################
# RTS-GMLC System using PSY
# Using tabular data generated by EGRET2SIIP from EGRET System JSON's
#####################################################
rts_dir = "/Users/sdhulipa/Desktop/OneDrive - NREL/NREL-Github/EGRET2SIIP/data/Converted_CSV_Files/13-Jan-22-12-2-13/RTS-GMLC"
base_MVA = 100.0
dir_name = "/Users/sdhulipa/Desktop/OneDrive - NREL/NREL-Github/EGRET2SIIP/src/main"
user_descriptors_file = joinpath(dir_name,"Descriptors","user_descriptors.yaml") 
generator_mapping_file = joinpath(dir_name,"Descriptors","generator_mapping.yaml")
timeseries_pointers_file = joinpath(rts_dir, "timeseries_pointers.csv")

rawsys = PSY.PowerSystemTableData(
    rts_dir,
    base_MVA,
    user_descriptors_file,
    timeseries_metadata_file = timeseries_pointers_file,
    generator_mapping_file = generator_mapping_file,
);
#=
#####################################################
# RTS-GMLC System using PSY
# Using source data
#####################################################
rts_dir = "/Users/sdhulipa/Desktop/OneDrive - NREL/NREL-Github/temp/RTS-GMLC"
rts_src_dir = joinpath(rts_dir, "RTS_Data", "SourceData");
rts_siip_dir = joinpath(rts_dir, "RTS_Data", "FormattedData", "SIIP");

rawsys = PSY.PowerSystemTableData(
    rts_src_dir,
    100.0,
    joinpath(rts_siip_dir, "user_descriptors.yaml"),
    timeseries_metadata_file = joinpath(rts_siip_dir, "timeseries_pointers.json"),
    generator_mapping_file = joinpath(rts_siip_dir, "generator_mapping.yaml"),
)
=#
#####################################################
# DA System - Transforming Single Time Series
#####################################################
sys_DA = PSY.System(rawsys; time_series_resolution = Dates.Hour(1));
PSY.transform_single_time_series!(sys_DA, 48, Dates.Hour(24))
#####################################################
# Parse initial_status.csv to assign initial status
# for Generator
# set_time_at_status! implemented for ThermalStandard,
# ThermalMultiStart, HydroEnergyReservoir,HydroPumpedStorage
# set_status! only implemented for ThermalStandard,
# ThermalMultiStart
#####################################################
sys_base = sys_DA.units_settings.base_value;
initial_status_csv_location = joinpath(pwd(),"data","initial_status.csv")
df_initial_status = DataFrames.DataFrame(CSV.File(initial_status_csv_location));

for col_name in names(df_initial_status)
    comp = get_component(Generator,sys_DA,col_name)
    if (typeof(comp) in [ThermalStandard, ThermalMultiStart])
        if (df_initial_status[1,col_name]<0)
            set_status!(comp, false)
            set_time_at_status!(comp, abs(df_initial_status[1,col_name]))
        else
            set_status!(comp, true)
            set_time_at_status!(comp, df_initial_status[1,col_name])
        end
        set_active_power!(comp,(df_initial_status[2,col_name]/sys_base))
    end
    if (typeof(comp) in [HydroEnergyReservoir,HydroPumpedStorage])
        if (df_initial_status[1,col_name]<0)
            #comp.status = false
            set_time_at_status!(comp, abs(df_initial_status[1,col_name]))
        else
            #comp.status = true
            set_time_at_status!(comp, df_initial_status[1,col_name])
        end
        set_active_power!(comp,(df_initial_status[2,col_name]/sys_base))
    end
end
#####################################################
# RT System - Transforming Single Time Series
#####################################################
sys_RT = PSY.System(rawsys; time_series_resolution = Dates.Minute(5));
PSY.transform_single_time_series!(sys_RT, 12, Dates.Minute(60))
# Remove Flex_Down and Fex_Up Services from RT System because
# time series doesn't exist in RT System
flex_down_comp = get_component(VariableReserve, sys_RT, "Flex_Down")
remove_component!(sys_RT, flex_down_comp)
flex_up_comp = get_component(VariableReserve, sys_RT, "Flex_Up")
remove_component!(sys_RT, flex_up_comp)
#####################################################
# # Operations Problem Template
#####################################################
template_uc = OperationsProblemTemplate()

# Branch Formulations
set_device_model!(template_uc, Line, StaticBranch)
set_device_model!(template_uc, Transformer2W, StaticBranch)
set_device_model!(template_uc, TapTransformer, StaticBranch)

# Injection Device Formulations
set_device_model!(template_uc, ThermalStandard, ThermalStandardUnitCommitment)
set_device_model!(template_uc, RenewableDispatch, RenewableFullDispatch)
set_device_model!(template_uc, PowerLoad, StaticPowerLoad)
set_device_model!(template_uc, HydroDispatch, FixedOutput)
set_device_model!(template_uc, HydroEnergyReservoir, HydroDispatchRunOfRiver)
set_device_model!(template_uc, RenewableFix, FixedOutput)

# Service Formulations
#set_service_model!(template_uc, VariableReserve{ReserveUp}, RangeReserve)
#set_service_model!(template_uc, VariableReserve{ReserveDown}, RangeReserve)

# Network Formulations
set_transmission_model!(template_uc, CopperPlatePowerModel)

# Optimizer
solver = optimizer_with_attributes(SCIP.Optimizer,"limits/gap" => 1e-4,"limits/time" => 500,"display/verblevel" => 4)

# Build the Operations Problem
#op_problem = OperationsProblem(template_uc, sys_DA; optimizer = solver, horizon = 24,initial_time = DateTime("2020-07-01T00:00:00"),optimizer_log_print = true)

#build!(op_problem, output_dir = mktempdir())
#####################################################
# Economic Dispatch
#####################################################
# ED Template
template_ed = template_economic_dispatch()
# Problems
problems = SimulationProblems(
    UC = OperationsProblem(template_uc, sys_DA, optimizer = solver,optimizer_log_print = true,balance_slack_variables = true),
    #ED = OperationsProblem(
     #   template_ed,
      #  sys_RT,
       # optimizer = solver,
       # balance_slack_variables = true,
        #optimizer_log_print = true
    #),
)
# Feed-Forward
feedforward_chronologies = Dict(("UC" => "ED") => Synchronize(periods = 24))

feedforward = Dict(
    ("ED", :devices, :ThermalStandard) => SemiContinuousFF(
        binary_source_problem = PSI.ON,
        affected_variables = [PSI.ACTIVE_POWER],
    ),
)

#intervals = Dict("UC" => (Hour(24), Consecutive()), "ED" => (Minute(60), Consecutive()))
intervals = Dict("UC" => (Hour(24), Consecutive()))

DA_RT_sequence = SimulationSequence(
    problems = problems,
    intervals = intervals,
    ini_cond_chronology = InterProblemChronology(),
    #feedforward_chronologies = feedforward_chronologies,
    #feedforward = feedforward,
)
# Simulation
sim = Simulation(
    name = "RTS-GMLC",
    steps = 14,
    problems = problems,
    sequence = DA_RT_sequence,
    simulation_folder = joinpath(pwd(), "data", "Results"),
    initial_time = DateTime("2020-07-01T00:00:00")
)

build!(sim)

execute!(sim, enable_progress_bar = false)

results = SimulationResults(sim);

# UC Results
results_uc = get_problem_results(results, "UC");
variables = PSI.read_realized_variables(results_uc);

save_to_csv("UC", variables)

# ED Results
results_ed = get_problem_results(results, "ED");
variables = PSI.read_realized_variables(results_ed);

save_to_csv("UC", variables)